{"version":3,"sources":["../source/Message.js"],"names":[],"mappings":";;;;;;;;AAAA;;;;AACA;;;;;;;;;;;;IAGqB,O;;;;;;;;;;;;;;qMASnB,e,GAAkB,UAAC,KAAD,EAAW;AAC3B,YAAK,WAAL;AACD,K;;;;;;;;;;;wCAEmB;AAClB,WAAK,OAAL,CAAa,KAAb,CAAmB,EAAnB,CAAsB,QAAtB,EAAgC,KAAK,eAArC;AACD;;;2CAEuB;AACtB,WAAK,OAAL,CAAa,KAAb,CAAmB,GAAnB,CAAuB,QAAvB,EAAiC,KAAK,eAAtC;AACD;;;;;;yCAGoB;AACnB,UAAM,QAAQ,KAAK,OAAL,CAAa,KAA3B;AACA,UAAM,QAAQ,MAAM,GAAN,EAAd;;AAGA,UAAG,CAAC,MAAM,OAAV,EAAkB;;AAEhB,aAAK,OAAL,CAAa,QAAb,CAAsB,IAAtB,CAA2B,MAAM,+BAAN,EAAuC,IAAvC,CAA4C,UAAC,QAAD,EAAc;AACnF,iBAAO,SAAS,IAAT,EAAP;AACD,SAF0B,EAExB,IAFwB,CAEnB,UAAC,IAAD,EAAU;;AAEhB,gBAAM,GAAN,GAAY,GAAZ,CAAgB,SAAhB,EAA0B,KAAK,OAA/B;AACD,SAL0B,CAA3B;AAMD;AAEF;;;6BAEQ;AACP,UAAM,QAAQ,KAAK,OAAL,CAAa,KAAb,CAAmB,GAAnB,EAAd;AACA,UAAG,CAAC,MAAM,OAAV,EACE,OAAO;AAAA;QAAA;QAAA;AAAA,OAAP,CADF,KAGE,OAAO;AAAA;QAAA;QAAI,MAAM;AAAV,OAAP;AACH;;;;;;AA7CkB,O,CAGZ,Y,GAAe;AACpB,SAAO,iBAAU,MADG;AAEpB,YAAU,iBAAU;AAFA,C;kBAHH,O","file":"Message.js","sourcesContent":["import React, {Component, PropTypes} from 'react';\nimport 'isomorphic-fetch';\n\n// Simple test of fetch with isomorphic rendering\nexport default class Message extends Component {\n\n  // The store is passed through from the App, the promises are passed through from out renderer\n  static contextTypes = {\n    store: PropTypes.object,\n    promises: PropTypes.array\n  }\n\n  // Listen to freezer changes\n  onFreezerChange = (event) => {\n    this.forceUpdate();\n  }\n\n  componentDidMount (){\n    this.context.store.on('update', this.onFreezerChange);\n  }\n\n  componentWillUnmount  (){\n    this.context.store.off('update', this.onFreezerChange); \n  }\n\n  // We place our fetches in componentWillMount so they run on both the client and server render.\n  componentWillMount (){\n    const store = this.context.store;\n    const state = store.get();\n    \n          \n    if(!state.message){\n      // Push a promise onto the stack so we know to wait for it on server render\n      this.context.promises.push(fetch('http://localhost:8080/message').then((response) => {      \n        return response.json();\n      }).then((json) => {        \n        // Update the store\n        store.get().set('message',json.message);\n      }));\n    }\n\n  }\n  \n  render() {\n    const state = this.context.store.get();\n    if(!state.message)\n      return <p>I'm fetching the message...</p>;\n    else\n      return <p>{state.message}</p>\n  }\n}"]}